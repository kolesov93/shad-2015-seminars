\documentclass[addpoints]{exam}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\title{Неразобранные задачи}
\author{Минский ШАД. Осень}

\input{preamble.tex}

\begin{document}

%\printanswers
\maketitle

\begin{questions}

\section{Графы}

\section{Безысходность}

В одной очень доброй стране есть $n$ горных шахт, в которых пока нет выходов наружу. Между некоторыми шахтами уже прорыты туннели, по которым можно проходить в обе стороны.

В стране часто случаются очень добрые землетрясения. Их доброта заключается в том, что они рушат не более одной шахты (возможно вообще не рушат). После разрушения становятся непригодными и все туннели, которые начинаются/заканчиваются в данной шахте.

Профсоюз шахтёров таки выбил поправку в законе стране, которая позволила рабочим выходить на свет. Посему правительство должно построить лифты из некоторых станций наружу. Более того, поправка утверждает, что после любого землетрясения шахтёры из любой неразрушенной шахты должны иметь возможность по исправным туннелям добраться до лифта.

Вы как очень добрый член правительства должны выбрать, в каких шахтах построить лифты. Но ваша забота о государстве превыше всего, а значит количество лифтов в вашем плане должно быть минимально возможным, чтоб удовлетворить всем условиям.

Решите эту задачу за $\mathcal{O}(n + m)$

\section{Разное}

\question[3] Дан массив из $n+1$ числа, в котором содержатся целые числа от $1$ до $n$ (какие-то числа могут отсутствовать). Необходимо найти любое такое $x$, что $x$ встречается в массиве как минимум дважды.

\begin{solution}

Рассмотрим граф из $n+1$ вершины, и дугами $i \rightarrow a_i$. В таком орграфе $n+1$ вершина и $n+1$ дуга, а значит он состоит только из циклов, каждая вершина которого~--- корень какого-нибудь корневого дерева.

Например, исходный массив:

\begin{center}

\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline 
$a_i$ & 3 & 1 & 2 & 1 & 4 & 3 & 7 & 4 \\ 
\hline 
$i$ & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 \\ 
\hline 
\end{tabular} 

\end{center}

Породит следующий граф:

\begin{center}

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={circle,fill=blue!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node, fill=green!] (1) {1};
  \node[main node] (2) [right of=1] {2};
  \node[main node] (3) [right of=2] {3};
  \node[main node, fill=green!] (4) [right of=3] {4};
  \node[main node] (5) [right of=4] {5};
  \node[main node] (6) [right of=5] {6};
  \node[main node] (7) [right of=6] {7};
  \node[main node] (8) [right of=7] {8};	

  \path[every node/.style={font=\sffamily\small}]
    (1) edge [bend right] node[left] {} (3)
    (2) edge node [left] {} (1)
    (3) edge node [left] {} (2)
    (4) edge [bend right] node[right] {} (1)
	(5) edge [left] node {} (4)
	(6) edge [loop below] node {} (6)
	(7) edge [bend right] node {} (4)
	(8) edge [bend left] node {} (4)
       ;
\end{tikzpicture}

\end{center}

Зелёным отмечены числа, которые подходят под ответ. Эти числа соответствуют вершинам, в которые входят больше одной дуги.

Забудем на время про ориентацию дуг. Посмотрим на компоненту связности, в которой лежит вершина $n+1$. Очевидно, что в этой компоненте есть цикл (в компоненте $m$ вершин и $m$ рёбер). Однако, вершина $n+1$ на цикле лежать не может (в неё не входит ни одна дуга)~--- значит если мы встанём в неё и будем идти по дугам, то рано или поздно придём в цикл. Заметим, что первая вершина цикла, в которую мы попадём обязательно будет <<зелёной>>. Действительно, в неё входит как минимум одна дуга из цикла и та дуга, по которой мы пришли.

Ну, теперь задача получилась простая. Надо встать в вершину $n+1$ и идти по дугам до цикла, а после найти первую вершину цикла. В данном случае можно сделать это так.

\begin{enumerate}

\item Сделаем от вершины $n+1$ ровно $n+1$ шаг. Пусть мы попали в вершину $x$. Очевидно, это вершина цикла (предпериод не может быть длинней $n+1$).

\item Пойдём от вершины $x$ по дугам и будем считать количество шагов, пока опять не попадём в вершину $x$. Пусть это количество $l$. Заметим, что $l$~--- длина цикла. 

\item Заведём два указателя. Один будет указывать на вершину $n+1$, другой на вершину через $l$ шагов от вершины $n+1$. Будем двигать эти указатели одновременно по шагу, пока они не станут указывать на одну и ту же вершину. Очевидно, что это и будет первая вершина цикла.

\end{enumerate}

\end{solution}


\question Дана матрица размером $n \times m$. Каждый элемент матрицы равен либо единице, либо нулю. Нужно преобразовать матрицу таким образом, чтоб элемент $a_{i,j}$ был равен $1$ тогда и только тогда, когда в строке $i$ есть хотя бы одна единица или в столбце $j$ есть хотя бы одна единица. 

\begin{parts}

\part[1] Решение должно иметь сложность $\mathcal{O}(nm)$
\part[1] Решение должно иметь сложность $\mathcal{O}(nm)$ и использовать лишь константу дополнительной памяти (т.е. результат должен оказаться в исходной матрице). Каждый элемент матрицы занимает один бит.

\end{parts}

\begin{solution}

Заметим, что задачу можно переформулировать так: если в позиции $(i,j)$ исходной матрицы стоит единица, то надо заполнить строку $i$ и столбец $j$ единицами в результирующей матрице.

Изначально запомним, есть ли в первой строке хотя бы одна единица. Затем для каждой строки, начиная со второй, будем делать следующее:

\begin{enumerate}

\item \label{itm:remember_one} Запомним есть ли в этой строке хотя бы одна единица. Эту информацию не будем запоминать между строками, так что памяти будет $\mathcal{O}(1)$

\item Если в столбце $j$ этой строки стоит единица, поставим единицы в $j$-й столбец первой строки

\item Если в пункте \ref{itm:remember_one} мы запомнили, что в этой строке была единица, то заполним всю строку единицами

\end{enumerate}

Теперь пройдёмся по первой строке и если встречаем единицу, то заполняем весь встреченный столбец единицами. Если мы изначально запомнили, что первая строка содеражала хотя бы одну единицу, то заполняем единицами всю строку. Полученная матрица~--- искомая.

\end{solution}



\question[\half] Дан массив, где \textbf{к}аждое число, кроме одного, повторяет\textbf{с}я два раза, а одно число~--- встречается только \textbf{о}дин раз. Надо найти это число за $1$ п\textbf{р}оход по массиву и $\mathcal{O}(1)$ дополнительной памяти.

\begin{solution}

Найдём $\oplus$-сумму всего массива~--- это и будет искомое число.

\end{solution}

\question[1 \half] Дан массив целых чисел, где каждое число, кроме $x$ и $y$, встречается по два раза, а числа $x$ и $y$~--- ровно по одному ($x \neq y$). Надо найти эти числа за $\mathcal{O}(n)$ времени и $\mathcal{O}(1)$ памяти.

\begin{solution}

Найдём $\oplus$-сумму всего массива~--- это будет $x \oplus y$. Обозначим эту сумму за $S$. Очевидно, что $S \neq 0$ ($x \neq y$). Найдём любой его единичный бит $i$ (позже покажем, как это сделать за константу времени). Мы знаем, что в этом бите числа $x$ и $y$ различаются. Будем считать, не теряя общности, что $x$ имеет $1$ в бите $i$, а $y$~--- $0$. Тогда найдём $S_0$~--- $\oplus$-сумму всех чисел, у которых в $i$-м бите стоит $0$, и аналогичную $S_1$~--- для всех чисел, у которых в $i$-м бите стоит единица. Тогда $x = S_1$, $y = S_0$. 

Научимся находить единичный бит у числа за $\mathcal{O}(1)$. Для этого заметим, что $\prev(x) = x \& (x - 1)$~--- это число $x$ с занулённым младшим единичным битом. Тогда, если мы вычислим $x \oplus \prev(x)$, то мы как раз получим число с одним взведённым битом~--- самым младшим единичным битом числа $x$.

Затем, для определения куда отнести число $z$: в $S_0$ или $S_1$ необходимо просто проверять результат $z \& (x \oplus \prev(x))$.

\end{solution}


\section{Геометрия}

\question Дано $n$ точек на плоскости. Необходимо сказать сколько треугольников на этих точках содержат точку $(0,0)$. 

\begin{parts}
\part[\half] Решение должно иметь сложность $\mathcal{O}(n^3)$

\part[\half] Решение должно иметь сложность $\mathcal{O}(n^2 \log{n})$

\part[1] Решение должно иметь сложность $\mathcal{O}(n \log{n})$
\end{parts}

\begin{solution}

Посчитаем количество треугольников, которые \textbf{не} содержат точку $(0,0)$, а затем вычтем из общего ($C_n^3$) количества треугольников найденное количество и получим ответ на задачу.

Все такие треугольники содержатся в одной полуплоскости относительно начала координат. Отсортируем все точки по углу, относительно $(0,0)$. Начнём с полуплоскости, полученной осью $oX$. Будем вращать её по часовой стрелке. Когда точка $A$ входит в полуплоскость, посчитаем сколько треугольников будет содержаться в этой новой полуплоскости и иметь $A$ как одну из вершин. Очевидно, что если в полуплоскости ровно $m$ точек, то количество искомых треугольников $C_m^2$. Число $m$ можно легко поддерживать: при вхождении точки увеличиваем его на $1$, при выходе~--- уменьшаем.

\end{solution}


\section{Структуры данных}

\question Предложить реализацию очереди, используя стурктуру данных стек. Разрешается использовать $\mathcal{O}(1)$ стеков и $\mathcal{O}(1)$ дополнительной памяти. Стек имеет две операции (<<push>> и <<pop>>), очередь тоже.

\begin{parts}

\part[\half] Амортизированная стоимость операций должна быть $\O{1}$

\part[2] Стоимость операций должна быть $\O{1}$ в худшем случае

\end{parts}

\begin{solution}

Для решения первой части можно использовать известную конструкцию из двух стеков, назовём их $A$ и $B$. При выполнении операции <<push>> будем добавлять элемент в стек $B$. При выполнении <<pull>>~--- достаем из стека $A$. Если же стек $A$ пуст, то просто перекладываем все элементы из стека $B$ в стек $A$. Легко показать, что тогда выполняется FIFO. Каждый элемент не более одного раза добавляется и достаётся из каждого из двух стеков.

Решение второго пункта довольно большое, описание его можно найти вот тут \url{http://goo.gl/VjEYxL}

\end{solution}

\question Предложить реализацию стека, используя стурктуру данных очередь. Стек имеет две операции (<<push>> и <<pop>>), очередь тоже. За $n$ будем считать максимальное количество элементов, которые могут находится в стеке в одно время.

\begin{parts}

\part[\half] Разрешается использовать $\O{n}$ дополнительной памяти

\part[\half] Стоимость операции <<push>> должна быть $\O{n}$, а <<pop>>~--- $\O{1}$. Дополнительной памяти~--- $\O{1}$

\part[\half] Стоимость операции <<pop>> должна быть $\O{n}$, а <<push>>~--- $\O{1}$

\part[2] (Амортизированная) Стоимость обеих операций должна быть $\o{n}$

\end{parts}

\begin{solution}

В первом пункте просто заведём стек в дополнительной памяти.

Будем реализовывать стек на одной очереди. Будем поддерживать в этой очереди порядок LIFO. Если надо забрать элемент, то просто заберём элемент из очереди. Если вставить, то поступим следующим образом. Запомним сколько элементов в очереди до добавления, пусть $m$. Добавим новый элемент в очередь. Затем сделаем $m$ раз связку <<pull>>-<<push>>, тем самым выведя новый элемент на первое место, а все остальные оставив за ним. На рисунке элементы пронумерованы в порядке добавления в структуру.

\begin{center}
\begin{tabular}{|c|c|}
\hline 
Промежуточное состояние структуры &  
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={fill=white!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node] (1) {4};
  \node[main node] (2) [right of=1] {3};
  \node[main node] (3) [right of=2] {2};
  \node[main node] (4) [right of=3] {1};
  
  \path[every node/.style={font=\sffamily\small}]
    (2) edge node [left] {} (1)
    (3) edge node [left] {} (2)
    (4) edge node [left] {} (3)
       ;
\end{tikzpicture}
\\ 
\hline 
<<pull>> & 
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={fill=white!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node, -, cross out, draw=red] (1) {4};
  \node[main node] (2) [right of=1] {3};
  \node[main node] (3) [right of=2] {2};
  \node[main node] (4) [right of=3] {1};
  
  \path[every node/.style={font=\sffamily\small}]
    (3) edge node [left] {} (2)
    (4) edge node [left] {} (3)
       ;
\end{tikzpicture}
\\
\hline
После <<pull>> & 
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={fill=white!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node] (2) [right of=1] {4};
  \node[main node] (3) [right of=2] {3};
  \node[main node] (4) [right of=3] {2};
  
  \path[every node/.style={font=\sffamily\small}]
    (3) edge node [left] {} (2)
    (4) edge node [left] {} (3)
       ;
\end{tikzpicture}
\\
\hline
Добавление элемента & 
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={fill=white!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node] (2) [] {4};
  \node[main node] (3) [right of=2] {3};
  \node[main node] (4) [right of=3] {2};
  \node[main node, fill=green!] (5) [right of=4] {5};
  
  \path[every node/.style={font=\sffamily\small}]
    (3) edge node [left] {} (2)
    (4) edge node [left] {} (3)
    (5) edge node [left] {} (4)
       ;
\end{tikzpicture}
\\
\hline
<<pull>>-<<push>> & 
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={fill=white!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node] (3) [] {3};
  \node[main node] (4) [right of=3] {2};
  \node[main node, fill=green!] (5) [right of=4] {5};
  \node[main node] (2) [right of=5] {4};  
  
  \path[every node/.style={font=\sffamily\small}]
    (4) edge node [left] {} (3)
    (5) edge node [left] {} (4)
    (2) edge node [left] {} (5)
       ;
\end{tikzpicture}
\\
\hline  
<<pull>>-<<push>> & 
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={fill=white!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node] (4) [] {2};
  \node[main node, fill=green!] (5) [right of=4] {5};
  \node[main node] (2) [right of=5] {4};  
  \node[main node] (3) [right of=2] {3};  
  
  \path[every node/.style={font=\sffamily\small}]
    (3) edge node [left] {} (2)
    (5) edge node [left] {} (4)
    (2) edge node [left] {} (5)
       ;
\end{tikzpicture}
\\
\hline
<<pull>>-<<push>> & 
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
  thick,main node/.style={fill=white!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node, fill=green!] (5) [] {5};
  \node[main node] (2) [right of=5] {4};  
  \node[main node] (3) [right of=2] {3};  
  \node[main node] (4) [right of=3] {2};
  
  \path[every node/.style={font=\sffamily\small}]
    (3) edge node [left] {} (2)
    (2) edge node [left] {} (5)
    (4) edge node [left] {} (3)
       ;
\end{tikzpicture}
\\
\hline
\end{tabular} 
\end{center}

Понятно, что можно при операции <<push>> просто добавлять элемент в очередь, а при <<pop>> делать серию <<pull>>-<<push>> дабы вывести самый последний элемент на первое место.

Приступим к интересной части. Реализуем операцию <<push>> за $\o{1}$ и <<pull>> за амортизированную оценку $\O{sqrt{n}}$. Заведём две очереди: $A$ и $B$. В первой будем хранить $\approx \sqrt{n}$ элементов самых близких к вершине стека (т.е. добавленных позже всего). Хранить их, однако, будем в порядке очереди (иначе сложность, вероятно, бы возрасла опять до $\O(n)$). При операции <<push>> просто добавляем элемент в очередь $A$. Если $|A|^2 > |B|$ перекидываем элемент верхней элемент очереди $A$ в $B$. Понятно, что таких перекидываний на <<push>> надо сделать не больше одного.

При операции <<pull>> серией <<pull>>-<<push>> очереди $B$ добиваемся, чтобы последний элемент стека оказался на вершине и возвращаем его. Заметим, что инвариант про $|A|^2 \leqslant |B|$ не нарушился.

Если же очередь $A$ пуста, то необходимо переупорядочить элементы. Для этого переместим (B.pull~-A.push) $\floor{|B| - \sqrt{|B|}}$ элементов из очереди $B$ в очередь $A$ и просто переименуем очереди. Теперь инвариант выполняется.

В качестве упражнения предлагается доказать, что амортизированная сложность операции <<pull>> составляет $\sqrt{n}$.


\end{solution}



\end{questions}

\end{document}
