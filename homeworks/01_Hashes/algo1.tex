\documentclass[addpoints]{exam}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\title{Хеширование}
\author{Минский ШАД. Осень}

\input{preamble.tex}

\DeclareMathOperator{\ord}{ord}
\DeclareMathOperator{\suf}{suf}
\DeclareMathOperator{\uniq}{uniq}
\DeclareMathOperator{\cnt}{cnt}


\begin{document}

\printanswers
\maketitle

\section{Обозначения}

В данной домашней работе будет много задач на строки. Введём следующие обозначения:

\begin{itemize}
\item $|s|$~--- длина строки $s$
\item $s[i]$~--- $i$-й символ строки $s$
\item $s[i \ldots j]$~--- подстрока строки $s$, которая начинается в индексе $i$ и заканчивается в индексе $j$
\item $\overline{s}$~--- <<перевёрнутая>> строка $s$ 
\item $\ord(c)$~--- произвольная инъективная функция из алфавита строки в целые числа. Тут будем считать, что символы пронумерованы по алфафиту, т.е. $\ord(a) = 1, \ord(b) = 2, \ldots$ 
\end{itemize}

Например, если $s = \mbox{<<abacaba>>}$, то:

\begin{itemize}
\item $|s| = 7$ 
\item $s[3] = \mbox{'s'}$
\item $s[1\ldots3] = \mbox{<<bac>>}$
\item $\overline{s[1 \ldots 3]} = \mbox{<<cab>>}$  
\end{itemize}


\begin{questions}

\section{Тематические задачи}

\question Предложить, как решать с помощью полиномиального хеширования следующие задачи (везде вам дана строка $s$, причём $|s| = n$):

\begin{parts}

\part[\half] По данным парам $(l_1, r_1)$ и $(l_2, r_2)$ отвечать на запрос, правда ли, что равны две строки $s[l_1 \ldots r_1]$ и $s[l_2 \ldots r_2]$ за $\O{1}$. Разрешается делать препроцесс за $\O{n}$

\part[\half] \label{reversed} По данным парам $(l_1, r_1)$ и $(l_2, r_2)$ отвечать на запрос, правда ли, что равны две строки $s[l_1 \ldots r_1]$ и $\overline{s[l_2 \ldots r_2]}$ за $\O{1}$. Разрешается делать препроцесс за $\O{n}$ 

\part[\half] \label{palind} По данной паре $(l, r)$ отвечать на запрос, правда ли, что строка $s[l \ldots r]$ является палиндромом за $\O{1}$. Разрешается делать препроцесс за $\O{n}$ 

\part[\half] \label{lcp} Найти по данным $(i,j)$ найти длину наибольшего общего префикса двух строк $s[i\ldots|s|]$ и $s[j\ldots|s|]$ за $\O{\log{n}}$. Разрешается препроцесс за $\O{n}$

\part[\half] \label{zet} Вычислить $z$-функцию строки за $\O{n \log n}$ (т.е. найти $z_i$ для всех $i = \overline{1 \ldots |s|}$). $z_i$~--- длина наидлиннейшей подстроки, которая начинается в символе с индексом $i$ и совпадает с префиксом строки.

\part[\half] \label{comparing} Для пары $(i,j)$ выяснить, какой префикс лексикографически меньше: который начинается в $i$ или который начинается в $j$. Время работы $\O{\log{n}}$. Препроцесс за $\O{n}$

\part[\half] \label{sufarray} Построить суффиксный массив для строки $s$ за время $\O{n \log^2{n}}$. $i$-суффиксом ($\suf_i$) назовём подстроку $s[i\ldots |s|]$. Суффиксный массив $a_i$~--- перестановка первых $n$ чисел, такая, что $\suf_{a_i} < \suf_{a_{i+1}}$ для любого $i=\overline{1\ldots{|s|-1}}$. Сравнение проводится лексикографически. 

\end{parts}

\begin{solution}

Повторим идею полиномиального хеширования. Рассмотрим строку <<abacaba>>. Зафиксируем число $p$ (для определённости возьмём тройку), модуль $N$ (для определённости возьмём $1234$) и каждому индесу $i$ поставим в соотвествие число $p^i \ord(s[i]) \mod N$. Также посчитаем куммулятивный массив таких сумм $h$ (тут тоже суммируем по модулю $N$):

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline 
$s_i$ & a & b & a & c & a & b & a \\ 
\hline 
i & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\ 
\hline 
$\ord(s_i)$ & 1 & 2 & 1 & 3 & 1 & 2 & 1 \\ 
\hline 
$p^i$ & 1 & 3 & 9 & 27 & 81 & 243 & 729 \\ 
\hline 
$a_i$ & 1 & 6 & 9 & 81 & 81 & 486 & 729 \\ 
\hline 
$h_i$ & 1 & 7 & 16 & 97 & 178 & 664 & 159 \\ 
\hline 
\end{tabular} 
\end{center}

Для удобства записи отождествим $s_i$ и $\ord(s_i)$ в дальнейшем рассуждении.

Пусть нас спросили, равны ли подстроки $s[1 \ldots 2]$ и $s[5 \ldots 6]$. Поступим так же, как обычно поступают с куммулятивным массивом, т.е. попробуем посчитать сумму на подотрезке. Что мы получим для первой подстроки: $h_2 - h_0 = p s_1 + p^2 s_2 = 15$, для второй: $h_6-h_4 = p^5 s_5 + p^6 s_6 = \left[\mbox{Вычисления по модулю}\right] = 1215$. 

Заметим, что полученные выражения отличаются лишь в показателях степеней. Естественный выход~--- домножить одну величину на <<разность>> между степенями, а именно $(h_2 - h_0) p^{5-1} = 15 \cdot 81 = 1215 = h_6 - h_4$. Т.е. хеши действительно совпали.

Таким образом, общий метод для проверки подстрок на совпдаение:

\begin{itemize}
\item Проверить, что $r_1 - l_1 = r_2 - l_2$, иначе строки сразу не равны
\item Пусть, не теряя общности, $l_1 \leqslant l_2$. Тогда проверим на равенство $(h_{r_1} - h_{l_1 - 1}) p^{l_2 - l_1}$ и $h_{r_2} - h_{l_2}$. Если хеши не совпали, то строки различны. Иначе можно с высокой долей уверенности говорить, что строки тоже совпадают.
\end{itemize}

Для пункта \ref{reversed} кроме хешей для строки $s$ предпросчитаем хеши для строки $\overline{s}$. Теперь надо просто находить разности из двух разных куммулятивных массивов.

Для пункта \ref{palind} воспользуемся решением предыдущего пункта (положим $l_1 = l_2$, $r_1 = r_2$)

Для пункта \ref{lcp} воспользуемся бинарным поиском по ответу, а именно будем перебирать длину этой подстроки и сравнивать подстроки описанным методом (пусть текущее значение длины строки~--- $k$, тогда можно положить $l_1 = i$, $r_1 = i + k - 1$, $l_2 = j$, $r_2 = j + k - 1$).

В пункте \ref{zet} надо лишь применить решение из \ref{lcp}, считая, что $j=0$.

В пункте \ref{comparing} найдём длину самой длинной подстроки, $i$-префикса и $j$-префикс (пункт \ref{lcp}), а затем сравним первый несовпадающий символ двух префиксов (просто посмотрев в строку на соответствующие места).

В пункте \ref{sufarray} просто отсортируем массив из первых $n$ чисел с помощью компоратора, описанного в пункте \ref{comparing}.


\end{solution}

\question Предложить функцию для хеширования мультимножеств. А именно, по мультимножеству $A$ и числу $m$ ваша функция $h(A, m)$ должна выдавать число в диапазоне $0\ldots..2^{m}-1$, такое что (можно считать, что у вас есть хеш-функция для любого возможного элемента мультимножества, которая вычисляется за $\O{1}$):

\begin{parts}

\part[\half] \label{hash_trivial} $h(A, m) = h(B, m)$, если $A = B$

\part[\half] \label{hash_easy} Функция должна быть легко обновляемая (т.е. при добавлении элемента в мультимножество должно быть можно пересчитать значение $h(A \cup \{x\}, m)$ за $\o{|A|^\varepsilon}$, для любого $\varepsilon > 0$) 

\part[\half] \label{hash_medium} Функция должна быть суръективна (можно считать, что функция хеширования элемента суръективна)

\part[3] \label{hash_hard} Функция должна быть стойкой. С целью упрощения будем считать, что функция стойкая, если выполняется хотя бы одно из двух:

\begin{itemize}
\item Рассмотрим конечное множество элементов $B$ и будем считать, что все элементы мультимножества лежат в $B$. Зададимся числом $n$ и рассмотрим множество мультимножеств $S_n = \{A : |A| \leqslant n\}$. Функцию будем называть стойкой, если $\forall m$ и для любого $k$ ($0 \leqslant k < 2^m $), $P\{h(A,m) = k | A \in S_n\} \to \frac{1}{2^m}$, при $n \to \infty$
\item Функцию будет называть стойкой, если для достаточного большого $m$ и $|A|$ $\nexists$ такая константа $k$, что $\forall |A|$ $\exists C,D$, такие что $|C| \leqslant k$, $|D| \leqslant k$ и $h(A, m) = h((A \cup C) \setminus D, m)$
\end{itemize}

\end{parts}

\begin{solution}

Для пункта \ref{hash_trivial} и \ref{hash_easy} подходит, например $h \equiv 0$. 

Для пункта \ref{hash_medium} можно использовать, например, $h(A) = \bigoplus\limits_{x \in A} H(x)$

Для пункта \ref{hash_hard} нужно использовать уже хорошие функции. Предыдущая функция не подходит, потому что можно дважды добавить один и тот же элемент и получить тот же хеш. Хорошей функцией может являться, например, такая $h(A) = \prod\limits_{x \in \uniq(A)} H(x)^{\cnt(x)}$, где $\cnt$~--- кратность элемента $x$ в $A$, а $\uniq$~--- множество всех элементов мультимножества. За доказательством этого факта можно обратиться \href{http://link.springer.com/chapter/10.1007%2F978-3-540-40061-5_12}{сюда}.

\end{solution}

\section{Задачи на повторение}

\question[\half] \label{binary_search} Дан отсортированный массив различных целых чисел. Надо определить, существует ли такой индекс $i$, что $a_i = i$. Сложность алгоритма должна быть $\O{\log{n}}$, где $n$~--- длина массива.

\begin{solution}

Так как числа целые и различные, то $a_i \geqslant a_{i - 1} + 1$. Рассмотрим функцию $f(i) = a_i - i$. Она неубывающая. Поэтому можно найти первую точку, где она не меньше нуля за $\O{\log{n}}$ с помощью бинарного поиска.

\end{solution}

\question[\half] Пусть мы имеем два положительные неубывающие функции $f(x)$ и $g(x)$, причём $f(n) = \O{g(n)}$. Правда, что $2^{f(n)} = \O{2^{g(n)}}$? Если это может как выполняться, так и не выполняться, привидете примеры обоих случаев. Иначе докажите утверждение.

\begin{solution}

Иногда это выполнятся, например $f(n) = g(n)$. В частности, это правда, если $f(n) \leqslant g(n)$, при $n \to \infty$.

С другой стороны, если, к примеру, $g(n) = 2f(n)$, то $2^{f(n)}$ и $2^{g(n)}$ отличаются уже не в константу раз.

\end{solution}

\question[\half] Пусть у нас есть $k$ отсортированных последовательностей из $n$ чисел каждая. Предлагается такой алгоритм слияния их в одну: сначала сольём две первых последовательности, затем результат с третьей, и так далее. Какова сложность полученного алгоритма? Считаем, что слияние двух массивов происходит за их суммарную длину. Какова сложность полученного алгоритма.

\begin{solution}

$$\sum\limits_{i=1}^{k-1} {n + in} = n \sum\limits_{i=1}^{k-1} {i + 1} = \O{n k^2}$$

\end{solution}


\section{Практические задачи}

\question[1] Реализуйте решение задачи про \hyperref[binary_search]{поиск $i = a_i$}. 

\question[1] Реализуйте решение задачи про \hyperref[sufarray]{суффиксный массив через хеши}. 

\end{questions}


\begin{center}
\pointtable[h][questions]
\end{center}


\end{document}