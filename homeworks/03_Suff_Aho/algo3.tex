\documentclass[addpoints]{exam}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\title{Алгоритм Ахо-Корасик. Суффиксные структуры}
\author{Минский ШАД. Осень}

\input{preamble.tex}

\DeclareMathOperator{\ord}{ord}
\DeclareMathOperator{\suf}{suf}
\DeclareMathOperator{\uniq}{uniq}
\DeclareMathOperator{\cnt}{cnt}


\begin{document}

%\printanswers
\maketitle

\section{Обозначения}


\begin{questions}

\section{Тематические задачи}

\question[1 \half] Маленькому Морзе на день рождения подарили набор $A$ из $N$ кодовых слов, причём суммарная длина всех слов равна $L$. Он хочет проверить, правда ли, что набор задаёт однозначно декодируемый код, т.е. из того, что $a_1 a_2 \ldots a_n = b_1 b_2 \ldots b_m$, где $\forall i: a_i \in A, b_i \in A$ верно, что $n=m$ и $\forall i: a_i = b_i$.

У малыша не так много времени, поэтому алгоритм должен иметь сложность $\O{LN}$.

\begin{solution}

Попробуем построить такие две последовательности кодовых слов так, чтобы из конкатенация совпала, хотя сами последовательности различались. Можно считать, что такие две последовательности начинаются с разных кодовых слов (иначе можно откидывать одинаковые пары, пока не встретим различие).

Переберём эту пару кодовых слов (т.е. те слова, которые будут равны $a_1$ и $b_1$). Очевидно, что одно из них длинней другого. Теперь будем следовать такому алгоритму. Пока одна из последовательностей короче (как конкатенация слов), чем другая, будем подбирать в более короткую такое слово, что его добавление не испортит равенства строк.

К примеру пусть на каком-то этапе алгоритма у нас получилась такая ситуация:

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
 \hline 
 • & • & • & б & р & е & с & т \\ 
 \hline 
 • & а & м & б & р & е & ? & ? \\ 
 \hline 
 \end{tabular}  
\end{center}

В такой ситуации в конец более короткой последовательности мы можем приписать слова <<стратосфера>>, <<стагнация>>, <<стоп>> или <<c>>, но не можем <<сила>>, <<есть>>, <<ума>>, <<не>> или <<надо>>.

Если можно выбрать несколько вариантов, то будем пробовать все (т.е. воспользуемся перебором с возвратом).

Если мы в какой-то момент смогли сравнять длины двух строк, то мы можем сказать, что код не однозначно декодируемый, иначе однозначно.

Конечно, такой алгоритм не будет удовлетворять заданному временному ограничению. Более того, он может работать бесконечно долго. Заметим, однако, что всё, что нас интересует на каждом шаге перебора, это какой суффикс остался от более длинной строки. Понятное дело, что если на какой-то момент мы получили суффикс, который уже хоть раз получали~--- то дальше углубляться в перебор не стоит.

Каждый суффикс более длинной строки~--- это суффикс одного из кодовых слов. Различных суффиксов не более $L$. Давайте заведём граф, где каждому из таких суффиксов поставим в соответствие веришну. Из каждой вершины попробуем провести дуги, которые будут соответствовать переходу в переборе. Т.е. мы должны перебрать слово, которое мы хотим приписать к более короткой строке и понять, правда ли, что его префикс совпадает с текущим суффиксом (либо он сам совпадает с префиксом этого суффикса). Понятно дело, что на такие запросы мы можем отвечать за $\O{1}$, построив предварительно суффиксный массив и LCP.

Единственная детали, что мы не можем позволить себе делать sparse-table в этой задаче, так как тогда сложность будет $\O{NL + L \log L}$. Заметим однако, что мы можем предпросчитать все ответы по построенному LCP заранее. Действительно просто найдём все наши кодовые слова и за линейный проход по массиву LCP получим ответы на  LCP-запросы для каждого суффикса.

\end{solution}

\question[1] Маленький Буль загадал бинарную строку из $N$ бит. Он посчитал по ней суффиксный массив и отдал вам его. Сможете ли вы отгадать строку, которую загадал малыш. Кстати, говоря он мог ошибиться и предоставить вам массив, которому не соответствует ни одной бинарной строки, тогда надо указать ему на ошибку. Тем не менее, малыш умён не по годам, поэтому если вы назовёте строку, которая порождает такой же массив, как и загаданная, то он по доброте душевной сочтёт загадку разгаданной.

Если вы будете решать загадку слишком долго, мылаш решит, что вы очень скучный человек и пойдёт к студентам киевского филиала, так что решите задачу за $\O{N}$.

\begin{solution}

Заметим, что если строка состоит из одних нулей или одних единиц, то массив будет выглядить $(n-1, n-2, \ldots, 0)$. Так что если на входе такой массив, то сразу выдадим ответ.

Иначе предположим, какой мог быть последний бит строки. Если он был нулевым, то, очевидно, суффикс только из этого бита должен стоять на первом месте суффиксного массива (нет строки меньше, чем <<0>>). Можем откинуть этот бит и решать задачу для строки на единицу короче. Если же это единица, то это самый маленький (лексикографически) суффикс, который начинается на единицу. Тогда можем найти его позицию в суффиксном массиве, все суффикс до него начинаются с нуля, все после него~--- с единицы (т.е. мы восстановили строку).

Осталось проверить эту строку. Можно просто построить суффиксный массив за линейное время и сравнить его с данным (этот шаг существеннен).

\end{solution}

\section{Задачи на повторение}

\section{Практические задачи}

Ссылка на контест: \url{https://contest.yandex.ru/contest/1080/problems/}

 
\begin{center}
\pointtable[h][questions]
\end{center}

\end{questions}

\end{document}
