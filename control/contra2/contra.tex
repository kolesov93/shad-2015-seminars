\documentclass[addpoints]{exam}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{matrix}
\title{Алгоритмы и структуры данных поиска. Итоговая контрольная}
\author{Минский ШАД. Весна}

\DeclareMathOperator{\myvalue}{value}

\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\input{preamble.tex}

\begin{document}

\maketitle

\begin{questions}

\question[1 \half] Проверить, что данный $(n,m)$-граф является деревом за $\O{n}$.

\question[1 \half] Пусть существует алгоритм $A$ для детерминированного нахождения медианы в массиве за $\O{n}$, где $n$~--- длина массива. Предложите алгоритм для детерминированного нахождения $k$-й порядковой статистики в массиве за $\O{n}$.

\question[2] Дана строка $S$. Добавим в бор все суффиксы этой строки. Назовём интересными вершинами те, у которых количество сыновей не равно единице. Докажите, что количество интересных вершин в боре не более, чем $2|S| + 3$.

\question Мальчик Лёша решил написать код для нахождения в отсортированном по возрастанию массиве $a$ из $n$ чисел первую такую позицию $i$, что $a_i > \myvalue$, либо возвращал $-1$, если такого числа в массиве нет. Для этого он написал следующий код.

\lstinputlisting[language=C++,frame=single,numbers=left]{lb.cpp}

Конечно же этот код содержит ошибку. 

\begin{parts}
\part[1 \half] Исправьте ровно один символ так, чтобы приведённый код стал решать поставленную задачу.
\part[1 \half] \textbf{Бонус:} Найдите 3 разных способа решить первый пункт.
\end{parts}
 
\question[2] Рассмотрим алгоритм $T$ сжатия бинарных строк (т.е. алгоритм, который инъективно переводит бинарную строку в бинарную строку). Для оценивания качества алгоритма на строке $S$ введём величину $k_T(S)$, равную длине образа строки $S$ при применении алгоритма $T$. Назовём алгоритм $T$ хорошим, если $\exists$ такая константа $c$, что $\forall$ таких $S$, что $|S| > c$ выполняется, что $k_T(S) < |S|$. Докажите, что хороших алгоритмов сжатия не существует.

\question Для всех $i= \overline{1\ldots n}$ определить количество таких троек натуральных чисел $(a,b,c)$, что $a \cdot b \cdot c = i$ за $\O{n \log{n}}$. Например, для числа $6$ таких способов ровно $9$.

\begin{parts}
\part[2] За $\O{n \log^2{n}}$
\part[2] За $\O{n \log{n}}$ 
\end{parts}

\question Дан неотрицательно взвешенный связный $(n,n)$-граф. Вам разрешается сделать предобработку этого графа за $\O{n}$. После этого вам нужно:

\begin{parts}
\part[2] По паре вершин $s$ и $t$ определить максимальный $s-t$ поток в данном графе (веса~--- пропускные способности рёбер). Отвечать нужно за $\O{\log{n}}$.
\part[1 \half] Определить минимальный разрез данного графа за $\O{1}$.
\end{parts}

\question[3] Два кольца заданы координатами своих центров и двумя радиусами. Необходимо определить площадь пересечения двух колец.

\question[3] В городе Б есть $n$ горизонтальных улиц и $m$ вертикальных. На пересечении каждой вертикальной и горизонтальной улицы есть дом. Других домов в городе Б нет, а значит можно ввести прямоугольную систему координат на домах. Т.е. будем говорить, что в точке $(x,y)$ расположен дом, если $1 \leqslant x \leqslant n$, $1 \leqslant y \leqslant m$. Вас как ответственного сотрудника поисковой компании интересует, как высок уровень любви к котикам в разных районах этого города. Для измерения этого показателя вы выбрали специальные числа $h$ и $w$. Районом будем называть прямоугольник с противоположными сторонами в $(x,y)$ и $(x+h,y+w)$ такой, что $1 \leqslant x \leqslant x + h \leqslant n$ и $1 \leqslant y \leqslant y + w \leqslant m$. Про каждый домик известно, как много раз в день хозяева дома используют поисковую систему для просмотра видео с котиками. Показатель любви района вычисляется как медианное количество раз, которое жители этого района заходят посмотреть котиков. По заданными числам $n$, $m$, $h$ и $w$, а также показателям любви в каждом доме, вычислите район, который больше всего любит котиков. Гарантируется, что $h \cdot w$ нечётно.

Например рассмотрим следующий пример: $n=4$, $m=5$, $w=3$, $h=1$, красным отмечен искомый район.

\begin{center}
\begin{tikzpicture}
\tikzset{square matrix/.style={
    matrix of nodes,
    column sep=-\pgflinewidth, row sep=-\pgflinewidth,
    nodes={draw,
      minimum height=#1,
      anchor=center,
      text width=#1,
      align=center,
      inner sep=0pt
    },
  },
  square matrix/.default=0.7cm
}


\matrix[square matrix]
{
1 & 1 & 0 & 1 & 2 \\
1 & 1 & 0 & 1 & 3 \\
1 & 0 &|[fill=red]| 2 &|[fill=red]| 2 &|[fill=red]| 4 \\
0 & 2 & 2 & 1 & 8 \\
};
\end{tikzpicture}
\end{center}

%

\question[2] Предложить алгоритм, который по заданному массиву целых чисел получит следующую в лексикографическом порядке перестановку этих чисел за $\O{n}$ времени и $\O{1}$ памяти либо говорит, что её нет. Например, для массива $(1,0,2,1,0)$ должна быть получена перестановка $(1,1,0,0,2)$.

\question[3] Пусть есть алгоритм $A$, который за полиномиальное время умеет вычислять в произвольном взвешенном графе самый дешёвый (по сумме весов рёбер) простой путь из вершины $x$ в вершину $y$. Предложите полиномиальный алгоритм поиска гамильтоновой цепи в графе.

\question[3] У сильного и независимого мужчины есть $n$ заначек с пивасиком. В процессе своего становления мужчина протоптал $m$ тропинок. Каждая тропинка характеризуется тремя числами $(a,b,c)$~--- это значит, что она соединяет заначку с номером $a$ и заначку с номером $b$, причём путь по этой тропинке занимает ровно $c$ минут. Ходить по тропинке можно в обе стороны. От каждой заначки можно добраться до каждой, возможно через другие.

В какой-то момент сильный и независимый мужчина понял, что так больше продолжаться не может. Начать он решил с малого, а именно уничтожить лишние тропинки. Он хочет оставить граф тропинок связным, то есть после убирания тропинок их должно остаться ровно $n-1$.

У мужчины с его закадычными друзьями есть славная традиция. Каждый год 31-го декабря сильный и независимый мужчина начинает праздничный обход всех заготовленных заначек. Он понимает, что дойдя до заначки с номером $i$, будет просто невежливо не потратить ровно $d_i$ секунд на академическое исследование данной заначки. Причём, конечно, проводить исследование необходимо каждый раз при приходе к заначке, даже если эта заначка уже была обойдена раньше. 

Для того, чтобы не пропустить основное празденство, мужчина хочет составить план обхода заначек. План должен начинаться в какой-то заначке $s$ (на выбор мужчины), обходить все заначки, а потом возвращаться к заначке $s$.

Помогите мужчине составить такой план, время исполнения которого минимально за $\O{m \log{m}}$.

Пусть, к примеру, карта заначек вот такая:

\begin{center}
\begin{tikzpicture}[<->,>=stealth',shorten >=1pt,auto,node distance=3cm,
  thick,main node/.style={circle,fill=blue!20,draw,font=\sffamily\Large\bfseries}]

  \node[main node] (1) {10};
  \node[main node] (2) [right of=1] {12};

  \path[every node/.style={font=\sffamily\small}]
    (1) edge node {7} (2);
\end{tikzpicture}
\end{center}

Тогда самый выгодный план такой:

\begin{itemize}
\item Стартовать в левой заначке (потратить $10$ секунд)
\item Дойти до правой заначки (потратить $7$ секунд)
\item Изучить правую заначку (потратить $12$ секунд)
\item Вернуться в левую заначку (потратить $7$ секунд)
\item Закончить в левой заначке (потратить $10$ секунд)
\end{itemize}

Таким образом, лучший план занимает $46$ секунд.

\question Дана строка $S$ над алфавитом из чисел от $1$ до $|S|$. Вам разрешается произвести препроцесс. 

Строка $T$ называется доминируемой, если существует символ, который встречается в этой строке $m$ раз, причём $m > \frac{|T|}{2}$.

Необходимо отвечать на запрос, правда ли, что подстрока $S[l\ldots r]$ является доминируемой.

Пусть $n = |S|$.

\begin{parts}
\part[1 \half] Препроцесс за $\O{n \sqrt{n}}$, ответ за $\O{\sqrt{n}}$
\part[1 \half] Препроцесс за $\O{n \log{n}}$, ответ за $\O{\log^2{n}}$
\part[3] Препроцесс за $\O{n}$, ответ за $\O{\log{n}}$
\end{parts}

\end{questions}

\begin{center}
\pointtable[h][questions]
\end{center}

\end{document}