\documentclass[addpoints]{exam}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[OT1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\title{Алгоритмы и структуры данных поиска. Контрольная}
\author{Минский ШАД. Весна}

\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}

\input{preamble.tex}

\begin{document}

\maketitle

\begin{questions}

\question[2] Дерево на $n$ вершинах задано своим списком рёбер. На каждом ребре написан вес ${w_{a,b} \in \mathbb{R}}$. Необходимо за $\mathcal{O}(n)$ предоставить вес самого тяжелого простого пути (вес пути~--- сумма весов рёбер). Вес пустого пути считается равным нулю. 

\begin{solution}
Подвесим дерево за любую вершину. Введём величину $f(x)$ равную весу самого тяжелого пути от вершины $x$ до какой-либо вершины её поддерева (включая саму вершину $x$). Введённую величину легко пересчитать через сыновей $S_x$ вершины $x$, а именно: 

$$f(x) = \max\left(0, \max_{y \in S_x}(w_{x,y} + f(y))\right)$$

Вычислять эту величину можно с помощью обхода в глубину.

Теперь для каждой вершины $x$ найдём $g(x)$ ~--- вес самого тяжёлого простого пути среди таких, что вершина $x$ является самой близкой (по количеству рёбер) к корню вершиной этого пути. Очевидно, что вес такого пути либо равен $f(x)$, либо $\max\limits_{y_1 \in S_x, y_2 \in S_x, y1 \neq y2} f(y_1) + w_{x, y_1} + f(y_2) + w_{x, y_2}$. Последнюю величину легко вычислить за $\mathcal{O}(|S_x|)$ ~--- нужно просто найти два максимума $f(y) + w_{x, y}$ по $S_x$. 

Таким образом, ответ на задачу~--- $\max\limits_x g(x)$

\end{solution}

\question Дан алфавит $\Sigma$, причём $|\Sigma| = n$. Пусть символы алфавита каким-то образом пронумерованы от $1$ до $n$. Пусть дана строка $S$, тогда полиномиальным хешем от этой строки назовём следующее число: $h(S) = \left(\sum\limits_{i=1}^{|S|} S_i p^i\right) \mod M$, где $p$ и $M$~--- известные числа. Задача: найти количество таких строк $S$, что $|S| = k$, а $h(S) = x$. Задачу нужно решить для всех $x=\overline{0\ldots M-1}$.

\begin{parts}
\part[\half] Решение должно иметь сложность $\O{k M^2}$.
\part[1] Решение должно иметь сложность $\O{\log{k} M^2}$.
\part[1] Решение должно иметь сложность $\O{M \log{M} \log{k}}$.
\end{parts}

\question[2] По числу $n$ предоставьте строку, на которой алгоритм КМП произведёт максимальное количество сравнений, и строку, на которой минимальное. Сколько сравнений проведёт алгоритм в каждом из случаев? Можно считать, что алфавит имеет размер как минимум $n$.

\question[2] Дан $(n,m)$-граф. Необходимо найти количество способов раскрасить его в два цвета таким образом, чтоб никакие две смежные вершины не были одного цвета. Время работы должно составлять $\O{n + m}$.

\question[3] Пусть вы пишете программу для компьютера, которая активно работает с массивом из $2^k$ машинных слов. Вдруг вы поняли, что вам часто приходится искать максимум  на подотрезке этого массива. Вы решили, что стоит использовать sparse-table. Но для реализации этой структуры понадобится $n=2^{k} \times k$ машинных слов. А свободного места в памяти у вас осталось лишь на $\floor{\frac{n}{3}}$ машинных слов. Предложите структуру, которая реализует такую же функциональность как и sparse-table (поиск максимума на любом отрезке за $\O{1}$), но влезет в данное ограничение.  

\begin{solution}

Давайте делать на каждом уровне максимум вперёд не на степень двойки, а на степень, к примеру 16. Конечно, тогда константа увеличится~--- на каждом этапе (и построения, и ответа на запрос) придётся выбирать максимум из 16 чисел, но это всё равно константно.

\end{solution}

\question[3] Дан алфавит из $n$ символов. Построить такую строку $S$ минимальной длины, что все $n^3$ троек символов из данного алфавита встречаются как подстроки в $S$. Сложность алгоритма должна быть линейна от размера получившейся строки. 

\question[3] У малыша Пабло есть $n$ красок (пронумерованных от единицы до $n$) и большое желание раскрасить квадратный холст $n \times n$ клеток с помощью этих красок. Изначально холст пустой (все клетки имеют цвет ноль). На $i$-й день малыш выбирает краску под номером $c_i$, которую ещё не выбирал раньше, и закрашивает прямоугольник состоящий из клеток $(x,y)$, где $l_i \leq x \leq r_i$, $d_i \leq y \leq u_i$. По полученному холсту восстановите любой возможный набор $(c_i,l_i,r_i,d_i,u_i)$, который порождает данный холст, за $\O{n^3}$.

Например, для следующего холста ответ может быть таким: $((3,1,2,1,2), (1,1,2,1,2), (2,2,2,3,3)$:

\begin{center}
\begin{tabular}{|c|c|c|}
\hline 
1 & 1 & 0 \\ 
\hline 
1 & 2 & 2 \\ 
\hline 
0 & 2 & 2 \\ 
\hline 
\end{tabular} 
\end{center}

\question[2] По числу $n$ определить $\bigoplus\limits_{i=0}^{n} i$ за время $\O{1}$, считая, что операция $\oplus$ (побитовое сложение по модулю два) двух чисел выполнятся за $\O{1}$.

\question Дан код:

\lstinputlisting[language=C++,frame=single,numbers=left]{pseudo_zet.cpp}

\begin{parts}
\part[1] Какой вектор вернёт функция для строки <<abacababrestabacaba>>?
\part[1 \half] Какое значение $\ans[50000]$ для строки $a^{10000} b^{10000} c^{20000} a^{10000} b^{30000} c^{12345}$? Буква в степени означает, что эта буква повторяется показатель степени раз.
\end{parts}


\question[2] Предложите способ реализовать следующий класс:

\begin{lstlisting}[language=C++,frame=single,numbers=left]
class SuperClass {
public:
  void registerValue(int currentTime, int value);
  int getRecentMin(int currentTime);
};
\end{lstlisting}

<<currentTime>>~--- время в секундах от начала отсчёта. Функция <<getRecentMin>> должна возвращать минимальное зарегистрированное значение за последние 1000 секунд. Можно считать, что для любых двух последовательных вызовов <<currentTime>> будет не убывать.

\end{questions}

\begin{center}
\pointtable[h][questions]
\end{center}

\end{document}